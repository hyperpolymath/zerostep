// SPDX-FileCopyrightText: 2024 Joshua Jewell
// SPDX-License-Identifier: MIT

//! CUE Metadata Generation with Dublin Core Compliance
//!
//! Generates dataset metadata following Dublin Core Metadata Initiative (DCMI) terms.

use crate::ImagePair;
use anyhow::Result;
use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::Path;

/// Dublin Core metadata elements as defined by DCMI
/// Reference: https://www.dublincore.org/specifications/dublin-core/dcmi-terms/
pub struct DublinCoreMetadata {
    // Required elements
    pub title: String,
    pub creator: String,
    pub subject: Vec<String>,
    pub description: String,
    pub publisher: String,
    pub contributor: Vec<String>,
    pub date: String,
    pub r#type: String,
    pub format: String,
    pub identifier: String,
    pub source: String,
    pub language: String,
    pub relation: Vec<String>,
    pub coverage: String,
    pub rights: String,

    // Extended elements
    pub audience: String,
    pub provenance: String,
    pub rights_holder: String,
    pub license: String,
}

impl Default for DublinCoreMetadata {
    fn default() -> Self {
        Self {
            title: "VAEDecodedImages-SDXL".to_string(),
            creator: "Joshua Jewell".to_string(),
            subject: vec![
                "VAE artifacts".to_string(),
                "diffusion models".to_string(),
                "AI image detection".to_string(),
                "SDXL".to_string(),
                "latent diffusion".to_string(),
            ],
            description: "Paired dataset of original images and their VAE-encoded/decoded \
                          counterparts for training AI image detection models to identify \
                          diffusion model artifacts.".to_string(),
            publisher: "Hugging Face".to_string(),
            contributor: vec!["alexandrainst".to_string()],
            date: chrono_lite_date(),
            r#type: "Dataset".to_string(),
            format: "image/png".to_string(),
            identifier: "joshuajewell/VAEDecodedImages-SDXL".to_string(),
            source: "alexandrainst/nordjylland-news-image-captioning".to_string(),
            language: "en".to_string(),
            relation: vec![
                "https://huggingface.co/datasets/alexandrainst/nordjylland-news-image-captioning".to_string(),
            ],
            coverage: "Danish newspaper TV2 Nord images".to_string(),
            rights: "See source dataset license".to_string(),
            audience: "AI/ML researchers, digital forensics".to_string(),
            provenance: "Images processed through SDXL VAE encode/decode pipeline".to_string(),
            rights_holder: "Original image rights holders".to_string(),
            license: "See source dataset".to_string(),
        }
    }
}

/// Get current date in ISO 8601 format without chrono dependency
fn chrono_lite_date() -> String {
    // Use a simple placeholder that will be replaced at runtime
    // In production, this would use system time
    "2024-01-01".to_string()
}

/// Generate CUE metadata file
pub fn write_metadata(
    output_dir: &Path,
    pairs: &[ImagePair],
    seed: u64,
    num_strata: usize,
) -> Result<()> {
    let metadata_path = output_dir.join("metadata.cue");
    let mut file = BufWriter::new(File::create(&metadata_path)?);

    let dc = DublinCoreMetadata::default();

    // Calculate statistics
    let total_pairs = pairs.len();
    let total_original_size: u64 = pairs.iter().map(|p| p.original_size).sum();
    let total_vae_size: u64 = pairs.iter().map(|p| p.vae_size).sum();
    let avg_original_size = total_original_size / total_pairs.max(1) as u64;
    let avg_vae_size = total_vae_size / total_pairs.max(1) as u64;

    // Count per stratum
    let mut stratum_counts: Vec<usize> = vec![0; num_strata];
    for pair in pairs {
        if pair.stratum < num_strata {
            stratum_counts[pair.stratum] += 1;
        }
    }

    writeln!(file, "// VAEDecodedImages-SDXL Dataset Metadata")?;
    writeln!(file, "// Generated by vae-normalizer v1.0.0")?;
    writeln!(file, "// Schema: Dublin Core Metadata Initiative (DCMI)")?;
    writeln!(file)?;
    writeln!(file, "package vae_dataset")?;
    writeln!(file)?;

    // Dublin Core metadata
    writeln!(file, "// Dublin Core Metadata (DCMI Terms)")?;
    writeln!(file, "dublin_core: {{")?;
    writeln!(file, "\ttitle:       \"{}\"", dc.title)?;
    writeln!(file, "\tcreator:     \"{}\"", dc.creator)?;
    writeln!(file, "\tsubject:     [{}]", dc.subject.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(", "))?;
    writeln!(file, "\tdescription: \"{}\"", dc.description)?;
    writeln!(file, "\tpublisher:   \"{}\"", dc.publisher)?;
    writeln!(file, "\tcontributor: [{}]", dc.contributor.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(", "))?;
    writeln!(file, "\tdate:        \"{}\"", dc.date)?;
    writeln!(file, "\ttype:        \"{}\"", dc.r#type)?;
    writeln!(file, "\tformat:      \"{}\"", dc.format)?;
    writeln!(file, "\tidentifier:  \"{}\"", dc.identifier)?;
    writeln!(file, "\tsource:      \"{}\"", dc.source)?;
    writeln!(file, "\tlanguage:    \"{}\"", dc.language)?;
    writeln!(file, "\trelation:    [{}]", dc.relation.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(", "))?;
    writeln!(file, "\tcoverage:    \"{}\"", dc.coverage)?;
    writeln!(file, "\trights:      \"{}\"", dc.rights)?;
    writeln!(file)?;
    writeln!(file, "\t// Extended Dublin Core")?;
    writeln!(file, "\taudience:     \"{}\"", dc.audience)?;
    writeln!(file, "\tprovenance:   \"{}\"", dc.provenance)?;
    writeln!(file, "\trights_holder: \"{}\"", dc.rights_holder)?;
    writeln!(file, "\tlicense:      \"{}\"", dc.license)?;
    writeln!(file, "}}")?;
    writeln!(file)?;

    // Dataset statistics
    writeln!(file, "// Dataset Statistics")?;
    writeln!(file, "statistics: {{")?;
    writeln!(file, "\ttotal_pairs:        {}", total_pairs)?;
    writeln!(file, "\ttotal_original_bytes: {}", total_original_size)?;
    writeln!(file, "\ttotal_vae_bytes:    {}", total_vae_size)?;
    writeln!(file, "\tavg_original_bytes: {}", avg_original_size)?;
    writeln!(file, "\tavg_vae_bytes:      {}", avg_vae_size)?;
    writeln!(file, "}}")?;
    writeln!(file)?;

    // Split configuration
    writeln!(file, "// Split Configuration")?;
    writeln!(file, "splits: {{")?;
    writeln!(file, "\tratios: {{")?;
    writeln!(file, "\t\ttrain:       0.70")?;
    writeln!(file, "\t\ttest:        0.15")?;
    writeln!(file, "\t\tvalidation:  0.10")?;
    writeln!(file, "\t\tcalibration: 0.05")?;
    writeln!(file, "\t}}")?;
    writeln!(file, "\tseed:       {}", seed)?;
    writeln!(file, "\tnum_strata: {}", num_strata)?;
    writeln!(file)?;
    writeln!(file, "\tstratum_counts: [")?;
    for (i, count) in stratum_counts.iter().enumerate() {
        writeln!(file, "\t\t{{ stratum: {}, count: {} }},", i, count)?;
    }
    writeln!(file, "\t]")?;
    writeln!(file, "}}")?;
    writeln!(file)?;

    // Checksum configuration
    writeln!(file, "// Cryptographic Integrity")?;
    writeln!(file, "checksums: {{")?;
    writeln!(file, "\talgorithm: \"SHAKE256\"")?;
    writeln!(file, "\toutput_bits: 256")?;
    writeln!(file, "\tnotation:  \"d=256\"")?;
    writeln!(file, "\treference: \"FIPS 202\"")?;
    writeln!(file, "}}")?;
    writeln!(file)?;

    // Processing pipeline
    writeln!(file, "// VAE Processing Pipeline")?;
    writeln!(file, "pipeline: {{")?;
    writeln!(file, "\tvae_model:     \"SDXL VAE\"")?;
    writeln!(file, "\tmax_dimension: 768")?;
    writeln!(file, "\tprocess:       \"encode -> latent -> decode\"")?;
    writeln!(file, "\toutput_format: \"PNG\"")?;
    writeln!(file, "}}")?;
    writeln!(file)?;

    // Formal verification
    writeln!(file, "// Formal Verification")?;
    writeln!(file, "verification: {{")?;
    writeln!(file, "\tproof_assistant: \"Isabelle/HOL\"")?;
    writeln!(file, "\ttheory_file:     \"VAEDataset_Splits.thy\"")?;
    writeln!(file, "\tproven_properties: [")?;
    writeln!(file, "\t\t\"disjoint_splits\",")?;
    writeln!(file, "\t\t\"exhaustive_splits\",")?;
    writeln!(file, "\t\t\"ratio_correctness\",")?;
    writeln!(file, "\t\t\"original_vae_bijection\",")?;
    writeln!(file, "\t]")?;
    writeln!(file, "}}")?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_dublin_core_default() {
        let dc = DublinCoreMetadata::default();
        assert_eq!(dc.title, "VAEDecodedImages-SDXL");
        assert!(!dc.subject.is_empty());
        assert!(!dc.description.is_empty());
    }

    #[test]
    fn test_metadata_generation() {
        let pairs = vec![
            ImagePair {
                id: "test1".to_string(),
                original_path: PathBuf::from("Original/test1.png"),
                vae_path: PathBuf::from("VAE/test1.png"),
                original_size: 1000,
                vae_size: 1200,
                original_checksum: "abc".to_string(),
                vae_checksum: "def".to_string(),
                stratum: 0,
            },
        ];

        let temp_dir = std::env::temp_dir();
        let result = write_metadata(&temp_dir, &pairs, 42, 4);
        assert!(result.is_ok());

        // Verify file was created
        let metadata_path = temp_dir.join("metadata.cue");
        assert!(metadata_path.exists());
    }
}
